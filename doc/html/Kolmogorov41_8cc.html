<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Kolmogorov41: src/Kolmogorov41.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kolmogorov41
   </div>
   <div id="projectbrief">Structurefunctions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Kolmogorov41.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Code to compute structure functions using velocity or scalar field data.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;h5si.h&quot;</code><br/>
<code>#include &lt;yaml-cpp/yaml.h&gt;</code><br/>
<code>#include &lt;iostream&gt;</code><br/>
<code>#include &lt;fstream&gt;</code><br/>
<code>#include &lt;hdf5.h&gt;</code><br/>
<code>#include &lt;sstream&gt;</code><br/>
<code>#include &lt;blitz/array.h&gt;</code><br/>
<code>#include &lt;omp.h&gt;</code><br/>
<code>#include &lt;mpi.h&gt;</code><br/>
<code>#include &lt;sys/time.h&gt;</code><br/>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2b9e63f5c7d28def453cfba49b74859a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a2b9e63f5c7d28def453cfba49b74859a">Read_para</a> ()</td></tr>
<tr class="memdesc:a2b9e63f5c7d28def453cfba49b74859a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to open the yaml file and parse the parameters.  <a href="#a2b9e63f5c7d28def453cfba49b74859a">More...</a><br/></td></tr>
<tr class="separator:a2b9e63f5c7d28def453cfba49b74859a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aede7be50f9f4215d24de0dad9179b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a16aede7be50f9f4215d24de0dad9179b">write_2D</a> (Array&lt; double, 2 &gt; A, string file)</td></tr>
<tr class="memdesc:a16aede7be50f9f4215d24de0dad9179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write the structure functions as function of l as a 2D hdf5 file.  <a href="#a16aede7be50f9f4215d24de0dad9179b">More...</a><br/></td></tr>
<tr class="separator:a16aede7be50f9f4215d24de0dad9179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e486782767b522541885ab5c5a7e32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a6e486782767b522541885ab5c5a7e32e">write_3D</a> (Array&lt; double, 3 &gt; A, string file, int q)</td></tr>
<tr class="memdesc:a6e486782767b522541885ab5c5a7e32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write the structure functions as function of lx,lz as a 2D hdf5 file.  <a href="#a6e486782767b522541885ab5c5a7e32e">More...</a><br/></td></tr>
<tr class="separator:a6e486782767b522541885ab5c5a7e32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952e4e10ef79a9b18af65437730f1080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a952e4e10ef79a9b18af65437730f1080">write_4D</a> (Array&lt; double, 4 &gt; A, string file, int q)</td></tr>
<tr class="memdesc:a952e4e10ef79a9b18af65437730f1080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to write the structure functions as function of lx,ly,lz as a 3D hdf5 file.  <a href="#a952e4e10ef79a9b18af65437730f1080">More...</a><br/></td></tr>
<tr class="separator:a952e4e10ef79a9b18af65437730f1080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bfe922b48296ebd38787354a0b87fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a08bfe922b48296ebd38787354a0b87fe">read_2D</a> (Array&lt; double, 2 &gt; A, string fold, string file)</td></tr>
<tr class="memdesc:a08bfe922b48296ebd38787354a0b87fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read a 2D field from an hdf5 file.  <a href="#a08bfe922b48296ebd38787354a0b87fe">More...</a><br/></td></tr>
<tr class="separator:a08bfe922b48296ebd38787354a0b87fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226edad97255b1ecf9cb6ccbaf68922b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a226edad97255b1ecf9cb6ccbaf68922b">int_to_str</a> (int <a class="el" href="Kolmogorov41_8cc.html#a86cf672daa4e0ad11ad10efc894d19c8">num</a>)</td></tr>
<tr class="memdesc:a226edad97255b1ecf9cb6ccbaf68922b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to convert an integer type value to string.  <a href="#a226edad97255b1ecf9cb6ccbaf68922b">More...</a><br/></td></tr>
<tr class="separator:a226edad97255b1ecf9cb6ccbaf68922b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab480edbbae700c7a118450b0f91c44e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ab480edbbae700c7a118450b0f91c44e8">VECTOR_TEST_CASE_3D</a> ()</td></tr>
<tr class="memdesc:ab480edbbae700c7a118450b0f91c44e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test function to validate the calculation of structure functions of 3D velocity field data.  <a href="#ab480edbbae700c7a118450b0f91c44e8">More...</a><br/></td></tr>
<tr class="separator:ab480edbbae700c7a118450b0f91c44e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eefe74fb861deaa5ec1731026867d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a18eefe74fb861deaa5ec1731026867d8">VECTOR_TEST_CASE_2D</a> ()</td></tr>
<tr class="memdesc:a18eefe74fb861deaa5ec1731026867d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test function to validate the calculation of structure functions of 2D velocity field data.  <a href="#a18eefe74fb861deaa5ec1731026867d8">More...</a><br/></td></tr>
<tr class="separator:a18eefe74fb861deaa5ec1731026867d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7e7caf5dc55122d18a389ce08d06b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a8e7e7caf5dc55122d18a389ce08d06b3">SCALAR_TEST_CASE_2D</a> ()</td></tr>
<tr class="memdesc:a8e7e7caf5dc55122d18a389ce08d06b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test function to validate the calculation of structure functions of 2D scalar field data.  <a href="#a8e7e7caf5dc55122d18a389ce08d06b3">More...</a><br/></td></tr>
<tr class="separator:a8e7e7caf5dc55122d18a389ce08d06b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c546f4066b4b9858c9f64e8a7401b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a06c546f4066b4b9858c9f64e8a7401b8">SCALAR_TEST_CASE_3D</a> ()</td></tr>
<tr class="memdesc:a06c546f4066b4b9858c9f64e8a7401b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test function to validate the calculation of structure functions of 3D scalar field data.  <a href="#a06c546f4066b4b9858c9f64e8a7401b8">More...</a><br/></td></tr>
<tr class="separator:a06c546f4066b4b9858c9f64e8a7401b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e9217b9dd150e770e3423b9a670447"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ab0e9217b9dd150e770e3423b9a670447">compute_time_elapsed</a> (timeval start_t, timeval end_t, double &amp;elapsed)</td></tr>
<tr class="memdesc:ab0e9217b9dd150e770e3423b9a670447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the time elapsed.  <a href="#ab0e9217b9dd150e770e3423b9a670447">More...</a><br/></td></tr>
<tr class="separator:ab0e9217b9dd150e770e3423b9a670447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed42719c00a36bb33994eace7a5fcc1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a4ed42719c00a36bb33994eace7a5fcc1">powInt</a> (double x, int n)</td></tr>
<tr class="memdesc:a4ed42719c00a36bb33994eace7a5fcc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function which conducts exponentiation with an integer as an exponent.  <a href="#a4ed42719c00a36bb33994eace7a5fcc1">More...</a><br/></td></tr>
<tr class="separator:a4ed42719c00a36bb33994eace7a5fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55606b6e28ce261a32fbb67004642e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#aed55606b6e28ce261a32fbb67004642e">read_3D</a> (Array&lt; double, 3 &gt; A, string fold, string file)</td></tr>
<tr class="memdesc:aed55606b6e28ce261a32fbb67004642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read a 3D field from an hdf5 file.  <a href="#aed55606b6e28ce261a32fbb67004642e">More...</a><br/></td></tr>
<tr class="separator:aed55606b6e28ce261a32fbb67004642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaf80f44d91adffa51dca33da5a8b1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#aaeaf80f44d91adffa51dca33da5a8b1b">SFunc2D</a> (Array&lt; double, 2 &gt; Ux, Array&lt; double, 2 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;SF_Node_p, Array&lt; double, 2 &gt; &amp;counter_Node)</td></tr>
<tr class="memdesc:aaeaf80f44d91adffa51dca33da5a8b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 2D velocity field.  <a href="#aaeaf80f44d91adffa51dca33da5a8b1b">More...</a><br/></td></tr>
<tr class="separator:aaeaf80f44d91adffa51dca33da5a8b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7045c373a28e9e12d84552f406ab1839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a7045c373a28e9e12d84552f406ab1839">SFunc2D</a> (Array&lt; double, 2 &gt; Ux, Array&lt; double, 2 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;SF_p_Node, Array&lt; double, 2 &gt; &amp;counter_Node, Array&lt; double, 3 &gt; &amp;SF_Grid2D_pll_Node, Array&lt; double, 3 &gt; &amp;SF_Grid2D_perp_Node, Array&lt; double, 3 &gt; &amp;counter_Grid2D_Node)</td></tr>
<tr class="memdesc:a7045c373a28e9e12d84552f406ab1839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 2D velocity field as function of (lx, lz) in addition to the structure functions as function of (l).  <a href="#a7045c373a28e9e12d84552f406ab1839">More...</a><br/></td></tr>
<tr class="separator:a7045c373a28e9e12d84552f406ab1839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0484229466aa1bb410a8432aebb0f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ac0484229466aa1bb410a8432aebb0f3f">SFunc_long_2D</a> (Array&lt; double, 2 &gt; Ux, Array&lt; double, 2 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node)</td></tr>
<tr class="memdesc:ac0484229466aa1bb410a8432aebb0f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A less computationally intensive function to calculate only the longitudinal structure functions using 2D velocity field.  <a href="#ac0484229466aa1bb410a8432aebb0f3f">More...</a><br/></td></tr>
<tr class="separator:ac0484229466aa1bb410a8432aebb0f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa690ba615c6dd5cb4e4cb8968a2f91bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#aa690ba615c6dd5cb4e4cb8968a2f91bb">SFunc_long_2D</a> (Array&lt; double, 2 &gt; Ux, Array&lt; double, 2 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node, Array&lt; double, 3 &gt; &amp;SF_Grid2D_pll_Node, Array&lt; double, 3 &gt; &amp;counter_Grid2D_Node)</td></tr>
<tr class="memdesc:aa690ba615c6dd5cb4e4cb8968a2f91bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A less computationally intensive function to calculate only the longitudinal structure functions as functions of (lx,lz) in addition to function of (l) using 2D velocity field.  <a href="#aa690ba615c6dd5cb4e4cb8968a2f91bb">More...</a><br/></td></tr>
<tr class="separator:aa690ba615c6dd5cb4e4cb8968a2f91bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c906faa1c5d93193db8fa749410e113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a7c906faa1c5d93193db8fa749410e113">SFunc3D</a> (Array&lt; double, 3 &gt; Ux, Array&lt; double, 3 &gt; Uy, Array&lt; double, 3 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;SF_Node_p, Array&lt; double, 2 &gt; &amp;counter_Node)</td></tr>
<tr class="memdesc:a7c906faa1c5d93193db8fa749410e113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 3D velocity field.  <a href="#a7c906faa1c5d93193db8fa749410e113">More...</a><br/></td></tr>
<tr class="separator:a7c906faa1c5d93193db8fa749410e113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a9ae43ac80dcae7cf66b7153f1def7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a07a9ae43ac80dcae7cf66b7153f1def7">SFunc3D</a> (Array&lt; double, 3 &gt; Ux, Array&lt; double, 3 &gt; Uy, Array&lt; double, 3 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;SF_p_Node, Array&lt; double, 2 &gt; &amp;counter_Node, Array&lt; double, 4 &gt; &amp;SF_Grid_pll_Node, Array&lt; double, 4 &gt; &amp;SF_Grid_perp_Node, Array&lt; double, 4 &gt; &amp;counter_Grid_Node)</td></tr>
<tr class="memdesc:a07a9ae43ac80dcae7cf66b7153f1def7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 3D velocity field as function of (lx, ly, lz) in addition to the structure functions as function of (l).  <a href="#a07a9ae43ac80dcae7cf66b7153f1def7">More...</a><br/></td></tr>
<tr class="separator:a07a9ae43ac80dcae7cf66b7153f1def7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2109ac253b8ba570101a85c8882597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a4d2109ac253b8ba570101a85c8882597">SFunc_long_3D</a> (Array&lt; double, 3 &gt; Ux, Array&lt; double, 3 &gt; Uy, Array&lt; double, 3 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node)</td></tr>
<tr class="memdesc:a4d2109ac253b8ba570101a85c8882597"><td class="mdescLeft">&#160;</td><td class="mdescRight">A less computationally intensive function to calculate only the longitudinal structure functions using 3D velocity field.  <a href="#a4d2109ac253b8ba570101a85c8882597">More...</a><br/></td></tr>
<tr class="separator:a4d2109ac253b8ba570101a85c8882597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72b8e548ece94d62dd87b2a9c1c5fe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ac72b8e548ece94d62dd87b2a9c1c5fe7">SFunc_long_3D</a> (Array&lt; double, 3 &gt; Ux, Array&lt; double, 3 &gt; Uy, Array&lt; double, 3 &gt; Uz, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node, Array&lt; double, 4 &gt; &amp;SF_Grid_pll_Node, Array&lt; double, 4 &gt; &amp;counter_Grid_Node)</td></tr>
<tr class="memdesc:ac72b8e548ece94d62dd87b2a9c1c5fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A less computationally intensive function to calculate only the longitudinal structure functions as functions of (lx,ly,lz) in addition to function of (l) using 3D velocity field.  <a href="#ac72b8e548ece94d62dd87b2a9c1c5fe7">More...</a><br/></td></tr>
<tr class="separator:ac72b8e548ece94d62dd87b2a9c1c5fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b18de8e8b7373822b819bada29f965"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a74b18de8e8b7373822b819bada29f965">Read_Init</a> (Array&lt; double, 2 &gt; &amp;Ux, Array&lt; double, 2 &gt; &amp;Uz)</td></tr>
<tr class="memdesc:a74b18de8e8b7373822b819bada29f965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assign an exponential function to the 2D velocity field.  <a href="#a74b18de8e8b7373822b819bada29f965">More...</a><br/></td></tr>
<tr class="separator:a74b18de8e8b7373822b819bada29f965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093ad1a7cd8cea6da650dcc4fec661f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a093ad1a7cd8cea6da650dcc4fec661f9">Read_Init</a> (Array&lt; double, 3 &gt; &amp;Ux, Array&lt; double, 3 &gt; &amp;Uy, Array&lt; double, 3 &gt; &amp;Uz)</td></tr>
<tr class="memdesc:a093ad1a7cd8cea6da650dcc4fec661f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assign an exponential function to the 3D velocity field.  <a href="#a093ad1a7cd8cea6da650dcc4fec661f9">More...</a><br/></td></tr>
<tr class="separator:a093ad1a7cd8cea6da650dcc4fec661f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121d669ca745afe3256d666b3b326ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a121d669ca745afe3256d666b3b326ecf">Read_Init</a> (Array&lt; double, 2 &gt; &amp;<a class="el" href="Kolmogorov41_8cc.html#a5b36daf4e0da59acd9285fb46cf268ea">T</a>)</td></tr>
<tr class="memdesc:a121d669ca745afe3256d666b3b326ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assign an exponential function to a 2D scalar field.  <a href="#a121d669ca745afe3256d666b3b326ecf">More...</a><br/></td></tr>
<tr class="separator:a121d669ca745afe3256d666b3b326ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf1a39a993f8781e16dab3c9227f976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a7bf1a39a993f8781e16dab3c9227f976">Read_Init</a> (Array&lt; double, 3 &gt; &amp;<a class="el" href="Kolmogorov41_8cc.html#a5b36daf4e0da59acd9285fb46cf268ea">T</a>)</td></tr>
<tr class="memdesc:a7bf1a39a993f8781e16dab3c9227f976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to assign an exponential function to a 3D scalar field.  <a href="#a7bf1a39a993f8781e16dab3c9227f976">More...</a><br/></td></tr>
<tr class="separator:a7bf1a39a993f8781e16dab3c9227f976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac097cb5c8b7c10149fe5afe2493c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a1ac097cb5c8b7c10149fe5afe2493c81">SF_scalar_3D</a> (Array&lt; double, 3 &gt; <a class="el" href="Kolmogorov41_8cc.html#a5b36daf4e0da59acd9285fb46cf268ea">T</a>, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node)</td></tr>
<tr class="memdesc:a1ac097cb5c8b7c10149fe5afe2493c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 3D scalar field.  <a href="#a1ac097cb5c8b7c10149fe5afe2493c81">More...</a><br/></td></tr>
<tr class="separator:a1ac097cb5c8b7c10149fe5afe2493c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd4fa7e667782e54bd2953c53daf82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a3bd4fa7e667782e54bd2953c53daf82e">SF_scalar_3D</a> (Array&lt; double, 3 &gt; <a class="el" href="Kolmogorov41_8cc.html#a5b36daf4e0da59acd9285fb46cf268ea">T</a>, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node, Array&lt; double, 4 &gt; &amp;SF_Grid_Node, Array&lt; double, 4 &gt; &amp;counter_Grid_Node)</td></tr>
<tr class="memdesc:a3bd4fa7e667782e54bd2953c53daf82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 3D scalar field as function of (lx, ly, lz) in addition to the structure functions as function of (l).  <a href="#a3bd4fa7e667782e54bd2953c53daf82e">More...</a><br/></td></tr>
<tr class="separator:a3bd4fa7e667782e54bd2953c53daf82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070ee3ae2e4784f49a379d7205e7698c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a070ee3ae2e4784f49a379d7205e7698c">SF_scalar_2D</a> (Array&lt; double, 2 &gt; <a class="el" href="Kolmogorov41_8cc.html#a5b36daf4e0da59acd9285fb46cf268ea">T</a>, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node)</td></tr>
<tr class="memdesc:a070ee3ae2e4784f49a379d7205e7698c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 2D scalar field.  <a href="#a070ee3ae2e4784f49a379d7205e7698c">More...</a><br/></td></tr>
<tr class="separator:a070ee3ae2e4784f49a379d7205e7698c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3819509d2d9399db0ae8826370414ff2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a3819509d2d9399db0ae8826370414ff2">SF_scalar_2D</a> (Array&lt; double, 2 &gt; <a class="el" href="Kolmogorov41_8cc.html#a5b36daf4e0da59acd9285fb46cf268ea">T</a>, Array&lt; double, 2 &gt; &amp;SF_Node, Array&lt; double, 2 &gt; &amp;counter_Node, Array&lt; double, 3 &gt; &amp;SF_Grid_Node, Array&lt; double, 3 &gt; &amp;counter_Grid_Node)</td></tr>
<tr class="memdesc:a3819509d2d9399db0ae8826370414ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate structure functions using 2D scalar field as function of (lx, lz) in addition to the structure functions as function of (l).  <a href="#a3819509d2d9399db0ae8826370414ff2">More...</a><br/></td></tr>
<tr class="separator:a3819509d2d9399db0ae8826370414ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddf1224851353fc92bfbff6f499fa97"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a0ddf1224851353fc92bfbff6f499fa97">main</a> (int argc, char *argv[])</td></tr>
<tr class="memdesc:a0ddf1224851353fc92bfbff6f499fa97"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main function of the "Strunc" code.  <a href="#a0ddf1224851353fc92bfbff6f499fa97">More...</a><br/></td></tr>
<tr class="separator:a0ddf1224851353fc92bfbff6f499fa97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad623b53bb9fae62a9a25d08e3ffd9f74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ad623b53bb9fae62a9a25d08e3ffd9f74">magnitude</a> (TinyVector&lt; double, 3 &gt; A, double &amp;mag)</td></tr>
<tr class="memdesc:ad623b53bb9fae62a9a25d08e3ffd9f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the magnitude of a 3D vector A.  <a href="#ad623b53bb9fae62a9a25d08e3ffd9f74">More...</a><br/></td></tr>
<tr class="separator:ad623b53bb9fae62a9a25d08e3ffd9f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e65d7e297f35291362d88607ad3b40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a58e65d7e297f35291362d88607ad3b40">magnitude</a> (TinyVector&lt; double, 2 &gt; A, double &amp;mag)</td></tr>
<tr class="memdesc:a58e65d7e297f35291362d88607ad3b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the magnitude of a 2D vector A.  <a href="#a58e65d7e297f35291362d88607ad3b40">More...</a><br/></td></tr>
<tr class="separator:a58e65d7e297f35291362d88607ad3b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5b36daf4e0da59acd9285fb46cf268ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b36daf4e0da59acd9285fb46cf268ea"></a>
Array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a5b36daf4e0da59acd9285fb46cf268ea">T</a></td></tr>
<tr class="memdesc:a5b36daf4e0da59acd9285fb46cf268ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the scalar field. <br/></td></tr>
<tr class="separator:a5b36daf4e0da59acd9285fb46cf268ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793e2580f28485ee24c5fa81dc49d6f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793e2580f28485ee24c5fa81dc49d6f5"></a>
Array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a793e2580f28485ee24c5fa81dc49d6f5">V1</a></td></tr>
<tr class="memdesc:a793e2580f28485ee24c5fa81dc49d6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the x-component of the 3D velocity field. <br/></td></tr>
<tr class="separator:a793e2580f28485ee24c5fa81dc49d6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e2fd1e10444329e59dc7024a4dca61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0e2fd1e10444329e59dc7024a4dca61"></a>
Array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ab0e2fd1e10444329e59dc7024a4dca61">V2</a></td></tr>
<tr class="memdesc:ab0e2fd1e10444329e59dc7024a4dca61"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the y-component of the 3D velocity field. <br/></td></tr>
<tr class="separator:ab0e2fd1e10444329e59dc7024a4dca61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a1dcc2241b131dda5545ee918b87d46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a1dcc2241b131dda5545ee918b87d46"></a>
Array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a5a1dcc2241b131dda5545ee918b87d46">V3</a></td></tr>
<tr class="memdesc:a5a1dcc2241b131dda5545ee918b87d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the z-component of the 3D velocity field. <br/></td></tr>
<tr class="separator:a5a1dcc2241b131dda5545ee918b87d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf4d825a1476fb60015ad46531ea361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf4d825a1476fb60015ad46531ea361"></a>
Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a7cf4d825a1476fb60015ad46531ea361">T_2D</a></td></tr>
<tr class="memdesc:a7cf4d825a1476fb60015ad46531ea361"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array storing the 2D scalar field. <br/></td></tr>
<tr class="separator:a7cf4d825a1476fb60015ad46531ea361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aabfce1918e76b1a9bcd9b8f393097c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aabfce1918e76b1a9bcd9b8f393097c"></a>
Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a8aabfce1918e76b1a9bcd9b8f393097c">V1_2D</a></td></tr>
<tr class="memdesc:a8aabfce1918e76b1a9bcd9b8f393097c"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the x-component of the 3D velocity field. <br/></td></tr>
<tr class="separator:a8aabfce1918e76b1a9bcd9b8f393097c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5cd2337ce83f1b30584612b88fa54c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b5cd2337ce83f1b30584612b88fa54c"></a>
Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a6b5cd2337ce83f1b30584612b88fa54c">V3_2D</a></td></tr>
<tr class="memdesc:a6b5cd2337ce83f1b30584612b88fa54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array storing the z-component of the 2D velocity field. <br/></td></tr>
<tr class="separator:a6b5cd2337ce83f1b30584612b88fa54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dccb635ea2de8c1b091798c112bc801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9dccb635ea2de8c1b091798c112bc801"></a>
Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a9dccb635ea2de8c1b091798c112bc801">SF</a></td></tr>
<tr class="memdesc:a9dccb635ea2de8c1b091798c112bc801"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array storing the computed longitudinal structure functions or scalar structure functions and their corresponding orders. <br/></td></tr>
<tr class="separator:a9dccb635ea2de8c1b091798c112bc801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80f1e666112772dc40391b8ca72cbac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae80f1e666112772dc40391b8ca72cbac"></a>
Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ae80f1e666112772dc40391b8ca72cbac">SF_perp</a></td></tr>
<tr class="memdesc:ae80f1e666112772dc40391b8ca72cbac"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array storing the computed transverse structure functions and their corresponding orders. <br/></td></tr>
<tr class="separator:ae80f1e666112772dc40391b8ca72cbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2c9adf66eddc3b8da9adaca24ba056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb2c9adf66eddc3b8da9adaca24ba056"></a>
Array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#acb2c9adf66eddc3b8da9adaca24ba056">counter</a></td></tr>
<tr class="memdesc:acb2c9adf66eddc3b8da9adaca24ba056"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D array storing the values to divide SF and SF_perp for averaging. <br/></td></tr>
<tr class="separator:acb2c9adf66eddc3b8da9adaca24ba056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24458a64d17b475028ddcb3d6873f97"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab24458a64d17b475028ddcb3d6873f97"></a>
Array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ab24458a64d17b475028ddcb3d6873f97">SF_Grid_pll</a></td></tr>
<tr class="memdesc:ab24458a64d17b475028ddcb3d6873f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">4D array storing the computed longitudinal structure functions as function of (lx, ly, lz, p), where p is the order. <br/></td></tr>
<tr class="separator:ab24458a64d17b475028ddcb3d6873f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7454bfcd2a402145f5b1f0bc545058"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e7454bfcd2a402145f5b1f0bc545058"></a>
Array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a2e7454bfcd2a402145f5b1f0bc545058">SF_Grid_perp</a></td></tr>
<tr class="memdesc:a2e7454bfcd2a402145f5b1f0bc545058"><td class="mdescLeft">&#160;</td><td class="mdescRight">4D array storing the computed transverse structure functions as function of (lx, ly, lz, p), where p is the order. <br/></td></tr>
<tr class="separator:a2e7454bfcd2a402145f5b1f0bc545058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cdfe984b21aaa9c0b85f21a1cf006a"><td class="memItemLeft" align="right" valign="top">Array&lt; double, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a76cdfe984b21aaa9c0b85f21a1cf006a">counter_Grid</a></td></tr>
<tr class="memdesc:a76cdfe984b21aaa9c0b85f21a1cf006a"><td class="mdescLeft">&#160;</td><td class="mdescRight">4D array storing the counter array for averaging SF_Grid_pll and SF_Grid_perp  <a href="#a76cdfe984b21aaa9c0b85f21a1cf006a">More...</a><br/></td></tr>
<tr class="separator:a76cdfe984b21aaa9c0b85f21a1cf006a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6284fb43435e4968d78bf0b6781ab5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d6284fb43435e4968d78bf0b6781ab5"></a>
Array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a4d6284fb43435e4968d78bf0b6781ab5">SF_Grid2D_pll</a></td></tr>
<tr class="memdesc:a4d6284fb43435e4968d78bf0b6781ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the computed longitudinal structure functions as function of (lx, lz, p), where p is the order. <br/></td></tr>
<tr class="separator:a4d6284fb43435e4968d78bf0b6781ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c9f2694ab7bf5db2a1517f8fa7b222"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17c9f2694ab7bf5db2a1517f8fa7b222"></a>
Array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a17c9f2694ab7bf5db2a1517f8fa7b222">SF_Grid2D_perp</a></td></tr>
<tr class="memdesc:a17c9f2694ab7bf5db2a1517f8fa7b222"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the computed transverse structure functions as function of (lx, ly, lz, p), where p is the order. <br/></td></tr>
<tr class="separator:a17c9f2694ab7bf5db2a1517f8fa7b222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc892d1cf95116c2c9967977c8034d48"><td class="memItemLeft" align="right" valign="top">Array&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#adc892d1cf95116c2c9967977c8034d48">counter_Grid2D</a></td></tr>
<tr class="memdesc:adc892d1cf95116c2c9967977c8034d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D array storing the counter array for averaging SF_Grid_pll and SF_Grid_perp  <a href="#adc892d1cf95116c2c9967977c8034d48">More...</a><br/></td></tr>
<tr class="separator:adc892d1cf95116c2c9967977c8034d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6229099a636aa31393cfa130c26452f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a6229099a636aa31393cfa130c26452f8">two_dimension_switch</a></td></tr>
<tr class="memdesc:a6229099a636aa31393cfa130c26452f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable decides whether the structure functions are to be calculated using 2D or 3D velocity field data.  <a href="#a6229099a636aa31393cfa130c26452f8">More...</a><br/></td></tr>
<tr class="separator:a6229099a636aa31393cfa130c26452f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920fbb672c00642a691eee2415e31c06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a920fbb672c00642a691eee2415e31c06">scalar_switch</a></td></tr>
<tr class="memdesc:a920fbb672c00642a691eee2415e31c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable decides whether the scalar or velocity structure functions are to be evaluated.  <a href="#a920fbb672c00642a691eee2415e31c06">More...</a><br/></td></tr>
<tr class="separator:a920fbb672c00642a691eee2415e31c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e04df29613e9ca17e5d1740907a43e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a20e04df29613e9ca17e5d1740907a43e">grid_switch</a></td></tr>
<tr class="memdesc:a20e04df29613e9ca17e5d1740907a43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable decides whether the structure functions as function of (lx, ly, lz), or of (lx, lz) in case of 2D, needs to be calculated in addition to the structure functions as function of (l).  <a href="#a20e04df29613e9ca17e5d1740907a43e">More...</a><br/></td></tr>
<tr class="separator:a20e04df29613e9ca17e5d1740907a43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c213bcc57b57816ceae212036b6681"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a70c213bcc57b57816ceae212036b6681">test_switch</a></td></tr>
<tr class="memdesc:a70c213bcc57b57816ceae212036b6681"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable decides whether the test cases are required to run.  <a href="#a70c213bcc57b57816ceae212036b6681">More...</a><br/></td></tr>
<tr class="separator:a70c213bcc57b57816ceae212036b6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfda77b016218238359bcc3e5c1600b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfda77b016218238359bcc3e5c1600b0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#abfda77b016218238359bcc3e5c1600b0">Nx</a></td></tr>
<tr class="memdesc:abfda77b016218238359bcc3e5c1600b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of gridpoints in the x direction. <br/></td></tr>
<tr class="separator:abfda77b016218238359bcc3e5c1600b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc9183c4659dc09e04e5ede1d79215b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adcc9183c4659dc09e04e5ede1d79215b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#adcc9183c4659dc09e04e5ede1d79215b">Ny</a></td></tr>
<tr class="memdesc:adcc9183c4659dc09e04e5ede1d79215b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of gridpoints in the y direction. <br/></td></tr>
<tr class="separator:adcc9183c4659dc09e04e5ede1d79215b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7576e08f5980d322da5f48c7385edc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a7576e08f5980d322da5f48c7385edc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a7a7576e08f5980d322da5f48c7385edc">Nz</a></td></tr>
<tr class="memdesc:a7a7576e08f5980d322da5f48c7385edc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of gridpoints in the z direction. <br/></td></tr>
<tr class="separator:a7a7576e08f5980d322da5f48c7385edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cf672daa4e0ad11ad10efc894d19c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86cf672daa4e0ad11ad10efc894d19c8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a86cf672daa4e0ad11ad10efc894d19c8">num</a></td></tr>
<tr class="memdesc:a86cf672daa4e0ad11ad10efc894d19c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of OpenMP threads. <br/></td></tr>
<tr class="separator:a86cf672daa4e0ad11ad10efc894d19c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a14aa552991b97c25b8d9ff3c7d66e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a14aa552991b97c25b8d9ff3c7d66e0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a7a14aa552991b97c25b8d9ff3c7d66e0">Nr</a></td></tr>
<tr class="memdesc:a7a14aa552991b97c25b8d9ff3c7d66e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of gridpoints in the diagonal direction. <br/></td></tr>
<tr class="separator:a7a14aa552991b97c25b8d9ff3c7d66e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07458ffa5504518f0e6eddebfcaed7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ae07458ffa5504518f0e6eddebfcaed7a">q1</a></td></tr>
<tr class="memdesc:ae07458ffa5504518f0e6eddebfcaed7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first order of the range of orders of the structure functions to be computed.  <a href="#ae07458ffa5504518f0e6eddebfcaed7a">More...</a><br/></td></tr>
<tr class="separator:ae07458ffa5504518f0e6eddebfcaed7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21845db0db765ccc24cfa65647998ebf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a21845db0db765ccc24cfa65647998ebf">q2</a></td></tr>
<tr class="memdesc:a21845db0db765ccc24cfa65647998ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last order of the range of orders of the structure functions to be computed.  <a href="#a21845db0db765ccc24cfa65647998ebf">More...</a><br/></td></tr>
<tr class="separator:a21845db0db765ccc24cfa65647998ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f513fa8d2e2fe662c220f6dd41a1e15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a6f513fa8d2e2fe662c220f6dd41a1e15">longitudinal</a></td></tr>
<tr class="memdesc:a6f513fa8d2e2fe662c220f6dd41a1e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable decides whether to calculate both transverse and longitudinal structure functions or only the longitudinal structure functions using a less computationally expensive technique.  <a href="#a6f513fa8d2e2fe662c220f6dd41a1e15">More...</a><br/></td></tr>
<tr class="separator:a6f513fa8d2e2fe662c220f6dd41a1e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229d11aff11a7482259d1296b9b70b8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229d11aff11a7482259d1296b9b70b8a"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a229d11aff11a7482259d1296b9b70b8a">dx</a></td></tr>
<tr class="memdesc:a229d11aff11a7482259d1296b9b70b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the distance between two consecutive gridpoints in the x direction. <br/></td></tr>
<tr class="separator:a229d11aff11a7482259d1296b9b70b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deb6f886b19d50e714d890c3c268efc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9deb6f886b19d50e714d890c3c268efc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a9deb6f886b19d50e714d890c3c268efc">dy</a></td></tr>
<tr class="memdesc:a9deb6f886b19d50e714d890c3c268efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the distance between two consecutive gridpoints in the y direction. <br/></td></tr>
<tr class="separator:a9deb6f886b19d50e714d890c3c268efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a198de8c3f38514f4e55231aa69cd10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a198de8c3f38514f4e55231aa69cd10"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a5a198de8c3f38514f4e55231aa69cd10">dz</a></td></tr>
<tr class="memdesc:a5a198de8c3f38514f4e55231aa69cd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the distance between two consecutive gridpoints in the z direction. <br/></td></tr>
<tr class="separator:a5a198de8c3f38514f4e55231aa69cd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb9745468202e28d4aedcd2f202bd12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fb9745468202e28d4aedcd2f202bd12"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a0fb9745468202e28d4aedcd2f202bd12">rank_mpi</a></td></tr>
<tr class="memdesc:a0fb9745468202e28d4aedcd2f202bd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the rank of the MPI process. <br/></td></tr>
<tr class="separator:a0fb9745468202e28d4aedcd2f202bd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad538aa77abb694f8faf437a41e3e8037"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad538aa77abb694f8faf437a41e3e8037"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#ad538aa77abb694f8faf437a41e3e8037">Lx</a></td></tr>
<tr class="memdesc:ad538aa77abb694f8faf437a41e3e8037"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the length of the domain. <br/></td></tr>
<tr class="separator:ad538aa77abb694f8faf437a41e3e8037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3d111ccf7f82fb80aeb6f8b229c21b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b3d111ccf7f82fb80aeb6f8b229c21b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#a9b3d111ccf7f82fb80aeb6f8b229c21b">Ly</a></td></tr>
<tr class="memdesc:a9b3d111ccf7f82fb80aeb6f8b229c21b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the breadth of the domain. <br/></td></tr>
<tr class="separator:a9b3d111ccf7f82fb80aeb6f8b229c21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5546164a9496b15d9ec38f2086d0e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca5546164a9496b15d9ec38f2086d0e5"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#aca5546164a9496b15d9ec38f2086d0e5">Lz</a></td></tr>
<tr class="memdesc:aca5546164a9496b15d9ec38f2086d0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the height of the domain. <br/></td></tr>
<tr class="separator:aca5546164a9496b15d9ec38f2086d0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef94be98e2c9e4a4dece75f60ca9792c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef94be98e2c9e4a4dece75f60ca9792c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Kolmogorov41_8cc.html#aef94be98e2c9e4a4dece75f60ca9792c">P</a></td></tr>
<tr class="memdesc:aef94be98e2c9e4a4dece75f60ca9792c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable stores the number of the MPI process. <br/></td></tr>
<tr class="separator:aef94be98e2c9e4a4dece75f60ca9792c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Code to compute structure functions using velocity or scalar field data. </p>
<dl class="section author"><dt>Author</dt><dd>Shashwat Bhattacharya, Shubhadeep Sadhukhan </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Jan 2020 </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>New BSD License </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab0e9217b9dd150e770e3423b9a670447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_time_elapsed </td>
          <td>(</td>
          <td class="paramtype">timeval&#160;</td>
          <td class="paramname"><em>start_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timeval&#160;</td>
          <td class="paramname"><em>end_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>elapsed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the time elapsed. </p>
<p>This function computes the time elapsed in seconds between a start point and an end point during the execution of the program</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_t</td><td>is the time corresponding to the start point </td></tr>
    <tr><td class="paramname">end_t</td><td>is the time corresponding to the end point </td></tr>
    <tr><td class="paramname">elapsed</td><td>stores the time elapsed in seconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a226edad97255b1ecf9cb6ccbaf68922b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string int_to_str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to convert an integer type value to string. </p>
<p>This function converts an integer type value to a string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>is the integer value of to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="ad623b53bb9fae62a9a25d08e3ffd9f74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void magnitude </td>
          <td>(</td>
          <td class="paramtype">TinyVector&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the magnitude of a 3D vector A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a tiny vector representing the 3D velocity field. </td></tr>
    <tr><td class="paramname">mag</td><td>is the variable that stores the magnitude calculated in this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58e65d7e297f35291362d88607ad3b40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void magnitude </td>
          <td>(</td>
          <td class="paramtype">TinyVector&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to compute the magnitude of a 2D vector A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a tiny vector representing the 2D velocity field. </td></tr>
    <tr><td class="paramname">mag</td><td>is the variable that stores the magnitude calculated in this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ddf1224851353fc92bfbff6f499fa97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main function of the "Strunc" code. </p>
<p>This function is the main function of the "Strunc" code for computing the velocity and scalar structure functions. The MPI decomposition and integration are also carried out in this function. </p>

</div>
</div>
<a class="anchor" id="a4ed42719c00a36bb33994eace7a5fcc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double powInt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function which conducts exponentiation with an integer as an exponent. </p>
<p>This function calculates x raised to the power n, where n is an integer. This function is faster than the standard pow(x,n) function for n&gt;2. Note that this function cannot accept a non-integer exponent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the base of double-precision floating point datatype. </td></tr>
    <tr><td class="paramname">n</td><td>is the exponent of integer datatype</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a08bfe922b48296ebd38787354a0b87fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read a 2D field from an hdf5 file. </p>
<p>This function reads an hdf5 file containing a 2D field, which can be the x or z component of a 2D velocity field. The dimensions of the 2D field is \((N_x \times N_z)\), where \(N_x\) and \(N_z\) are the number of gridpoints in x and z directions respectively. The hdf5 file should have only one dataset, and the names of the hdf5 file and the dataset must be identical. This function make use of the H5SI library for reading the hdf5 file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the 2D array to store the field that is read from the file. </td></tr>
    <tr><td class="paramname">fold</td><td>is the name of the folder in which the input files are kept. </td></tr>
    <tr><td class="paramname">file</td><td>is a string storing the name of the file to be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed55606b6e28ce261a32fbb67004642e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>fold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to read a 3D field from an hdf5 file. </p>
<p>This function reads an hdf5 file containing a 4D field, which can be the x y, or z component of a 3D velocity field. The dimensions of the 3D field is \((N_x \times N_y \times N_z)\), where \(N_x\), \(N_y\), and \(N_z\) are the number of gridpoints in x, y, and z directions respectively. The hdf5 file should have only one dataset, and the names of the hdf5 file and the dataset must be identical. This function make use of the H5SI library for reading the hdf5 file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the 3D array to store the field that is read from the file. </td></tr>
    <tr><td class="paramname">fold</td><td>is the name of the folder in which the input files are kept. </td></tr>
    <tr><td class="paramname">file</td><td>is a string storing the name of the file to be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74b18de8e8b7373822b819bada29f965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Read_Init </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Uz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to assign an exponential function to the 2D velocity field. </p>
<p>This function assigns the following exponential function to the 2D velocity field. \(U_x = x, \quad U_z = z\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 2D array representing the x-component of 2D velocity field. </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 2D array representing the z-component of 2D velocity field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a093ad1a7cd8cea6da650dcc4fec661f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Read_Init </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Uy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Uz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to assign an exponential function to the 3D velocity field. </p>
<p>This function assigns the following exponential function to the 3D velocity field. \(U_x = x, \quad U_y = y, \quad U_z = z\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 3D array representing the x-component of 3D velocity field. </td></tr>
    <tr><td class="paramname">Uy</td><td>is a 3D array representing the y-component of 3D velocity field. </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 3D array representing the z-component of 3D velocity field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a121d669ca745afe3256d666b3b326ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Read_Init </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to assign an exponential function to a 2D scalar field. </p>
<p>This function assigns the following exponential function to the scalar field. \(T = x + z \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>is a 2D array representing the x-component of 2D velocity field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bf1a39a993f8781e16dab3c9227f976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Read_Init </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to assign an exponential function to a 3D scalar field. </p>
<p>This function assigns the following exponential function to the scalar field. \(T = x + y + z \)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>is a 3D array representing the x-component of 2D velocity field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b9e63f5c7d28def453cfba49b74859a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Read_para </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to open the yaml file and parse the parameters. </p>
<p>The function opens the parameters.yaml file and parses the simulation parameters into its member variables that are publicly accessible. </p>

</div>
</div>
<a class="anchor" id="a8e7e7caf5dc55122d18a389ce08d06b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCALAR_TEST_CASE_2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test function to validate the calculation of structure functions of 2D scalar field data. </p>
<p>This function validates the calculation of the structure functions computed using 3D scalar field data. The scalar field is generated as \( \theta = x + z \). For such field, the structure functions of order \( q \) is given as \( S_q^u(l_x, l_z) = (l_x^2 + l_z^2)^q \). In this function, the theoretical values obtained from the aforementioned equation are compared with the computed values. If the difference between the two values is less than \(1 \times 10^{-10} \), the test is passed. </p>

</div>
</div>
<a class="anchor" id="a06c546f4066b4b9858c9f64e8a7401b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SCALAR_TEST_CASE_3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test function to validate the calculation of structure functions of 3D scalar field data. </p>
<p>This function validates the calculation of the structure functions computed using 3D scalar field data. The scalar field is generated as \( \theta = x + y + z \). For such field, the structure functions of order \( q \) is given as \( S_q^u(l_x, l_y, l_z) = (l_x^2 + l_y^2 + l_z^2)^q \). In this function, the theoretical values obtained from the aforementioned equation are compared with the computed values. If the difference between the two values is less than \(1 \times 10^{-10} \), the test is passed. </p>

</div>
</div>
<a class="anchor" id="a070ee3ae2e4784f49a379d7205e7698c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SF_scalar_2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 2D scalar field. </p>
<p>The following function computes both the nodal structure functions of 2D scalar field using four nested for-loops. The outer two for-loops correspond to the vector \(\mathbf{r}\) and the inner two loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>is a 2D array representing the scalar field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3819509d2d9399db0ae8826370414ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SF_scalar_2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Grid_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 2D scalar field as function of (lx, lz) in addition to the structure functions as function of (l). </p>
<p>The following function computes both the nodal structure functions of 2D scalar field using four nested for-loops. The outer two for-loops correspond to the vector \(\mathbf{r}\) and the inner two loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>is a 2D array representing the scalar field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal structure functions as function of (l) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
    <tr><td class="paramname">SF_Grid_Node</td><td>is a 3D array containing the values of the nodal structure functions as function of (lx,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Grid_Node</td><td>is a 3D array containing the numbers for dividing the values of SF_Grid_pll_Node so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ac097cb5c8b7c10149fe5afe2493c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SF_scalar_3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 3D scalar field. </p>
<p>The following function computes both the nodal structure functions of 3D scalar field using six nested for-loops. The outer three for-loops correspond to the vector \(\mathbf{r}\) and the inner three loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>is a 3D array representing the scalar field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3bd4fa7e667782e54bd2953c53daf82e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SF_scalar_3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Grid_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 3D scalar field as function of (lx, ly, lz) in addition to the structure functions as function of (l). </p>
<p>The following function computes both the nodal structure functions of 3D scalar field using six nested for-loops. The outer three for-loops correspond to the vector \(\mathbf{r}\) and the inner three loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>is a 3D array representing the scalar field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal structure functions as function of (l) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
    <tr><td class="paramname">SF_Grid_Node</td><td>is a 4D array containing the values of the nodal structure functions as function of (lx,ly,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Grid_Node</td><td>is a 4D array containing the numbers for dividing the values of SF_Grid_pll_Node so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaeaf80f44d91adffa51dca33da5a8b1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 2D velocity field. </p>
<p>The following function computes both the nodal longitudinal and transverse structure functions of 2D velocity field using four nested for-loops. The outer two for-loops correspond to the vector \(\mathbf{r}\) and the inner two loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 2D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 2D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">SF_Node_p</td><td>is a 2D array containing the values of the nodal transverse structure functions for orders q1 to q2. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node and SF_Node_p so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7045c373a28e9e12d84552f406ab1839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_p_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid2D_pll_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid2D_perp_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Grid2D_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 2D velocity field as function of (lx, lz) in addition to the structure functions as function of (l). </p>
<p>The following function computes both the nodal longitudinal and transverse structure functions of 2D velocity field using six nested for-loops. The outer three for-loops correspond to the vector \(\mathbf{r}\) and the inner three loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 2D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 2D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions as function of (l) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">SF_p_Node</td><td>is a 2D array containing the values of the nodal transverse structure functions for as function of (l) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node and SF_Node_p so as to get the average. </td></tr>
    <tr><td class="paramname">SF_Grid2D_pll_Node</td><td>is a 3D array containing the values of the nodal longitudinal structure functions as function of (lx,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">SF_Grid2D_perp_Node</td><td>is a 3D array containing the values of the nodal transverse structure functions for as function of (lx,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Grid2D_Node</td><td>is a 3D array containing the numbers for dividing the values of SF_Grid_pll_Node and SF_Grid_perp_Node_p so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7c906faa1c5d93193db8fa749410e113"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 3D velocity field. </p>
<p>The following function computes both the nodal longitudinal and transverse structure functions of 3D velocity field using six nested for-loops. The outer three for-loops correspond to the vector \(\mathbf{r}\) and the inner three loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 3D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uy</td><td>is a 3D array representing the y-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 3D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">SF_Node_p</td><td>is a 2D array containing the values of the nodal transverse structure functions for orders q1 to q2. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node and SF_Node_p so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07a9ae43ac80dcae7cf66b7153f1def7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_p_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid_pll_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid_perp_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Grid_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to calculate structure functions using 3D velocity field as function of (lx, ly, lz) in addition to the structure functions as function of (l). </p>
<p>The following function computes both the nodal longitudinal and transverse structure functions of 3D velocity field using six nested for-loops. The outer three for-loops correspond to the vector \(\mathbf{r}\) and the inner three loops correspond to the vector \(\mathbf{r+l}\). The second for-loop is parallelized using OpenMP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 3D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uy</td><td>is a 3D array representing the y-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 3D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions as function of (l) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">SF_p_Node</td><td>is a 2D array containing the values of the nodal transverse structure functions for as function of (l) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node and SF_Node_p so as to get the average. </td></tr>
    <tr><td class="paramname">SF_Grid_pll_Node</td><td>is a 4D array containing the values of the nodal longitudinal structure functions as function of (lx,ly,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">SF_Grid_perp_Node</td><td>is a 4D array containing the values of the nodal transverse structure functions for as function of (lx,ly,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Grid_Node</td><td>is a 4D array containing the numbers for dividing the values of SF_Grid_pll_Node and SF_Grid_perp_Node_p so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0484229466aa1bb410a8432aebb0f3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc_long_2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A less computationally intensive function to calculate only the longitudinal structure functions using 2D velocity field. </p>
<p>The following function computes the only longitudinal structure function using 2D velocity field data. This function is less computationally expensive compared to SFunc3D. The function exploits the fact that \( \langle du(l)^p \rangle = \langle du(-l)^p \rangle \), where \( du(l) \) is the component parallel to l. Thus, although this function uses four nested loops, the innermost loop starts from z1 instead of 0, where z1 is the iteration number of the second for-loop. The rest of the structure is similar to the function SFunc2D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 3D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 3D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa690ba615c6dd5cb4e4cb8968a2f91bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc_long_2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid2D_pll_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Grid2D_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A less computationally intensive function to calculate only the longitudinal structure functions as functions of (lx,lz) in addition to function of (l) using 2D velocity field. </p>
<p>The following function computes the only longitudinal structure function using 2D velocity field data. This function is less computationally expensive compared to SFunc2D. The function exploits the fact that \( \langle du(l)^p \rangle = \langle du(-l)^p \rangle \), where \( du(l) \) is the component parallel to l. Thus, although this function uses six nested loops, the innermost loop starts from z1 instead of 0, where z1 is the iteration number of the third for-loop. The rest of the structure is similar to the function SFunc3D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 2D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 2D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
    <tr><td class="paramname">SF_Grid2D_pll_Node</td><td>is a 3D array containing the values of the nodal longitudinal structure functions as function of (lx,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Grid2D_Node</td><td>is a 3D array containing the numbers for dividing the values of SF_Grid_pll_Node so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d2109ac253b8ba570101a85c8882597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc_long_3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A less computationally intensive function to calculate only the longitudinal structure functions using 3D velocity field. </p>
<p>The following function computes the only longitudinal structure function using 3D velocity field data. This function is less computationally expensive compared to SFunc3D. The function exploits the fact that \( \langle du(l)^p \rangle = \langle du(-l)^p \rangle \), where \( du(l) \) is the component parallel to l. Thus, although this function uses six nested loops, the innermost loop starts from z1 instead of 0, where z1 is the iteration number of the third for-loop. The rest of the structure is similar to the function SFunc3D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 3D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uy</td><td>is a 3D array representing the y-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 3D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac72b8e548ece94d62dd87b2a9c1c5fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SFunc_long_3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>Uz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF_Grid_pll_Node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array&lt; double, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>counter_Grid_Node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A less computationally intensive function to calculate only the longitudinal structure functions as functions of (lx,ly,lz) in addition to function of (l) using 3D velocity field. </p>
<p>The following function computes the only longitudinal structure function using 3D velocity field data. This function is less computationally expensive compared to SFunc3D. The function exploits the fact that \( \langle du(l)^p \rangle = \langle du(-l)^p \rangle \), where \( du(l) \) is the component parallel to l. Thus, although this function uses six nested loops, the innermost loop starts from z1 instead of 0, where z1 is the iteration number of the third for-loop. The rest of the structure is similar to the function SFunc3D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ux</td><td>is a 3D array representing the x-component of velocity field </td></tr>
    <tr><td class="paramname">Uy</td><td>is a 3D array representing the y-component of velocity field </td></tr>
    <tr><td class="paramname">Uz</td><td>is a 3D array representing the z-component of velocity field </td></tr>
    <tr><td class="paramname">SF_Node</td><td>is a 2D array containing the values of the nodal longitudinal structure functions for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Node</td><td>is a 2D array containing the numbers for dividing the values of SF_Node so as to get the average. </td></tr>
    <tr><td class="paramname">SF_Grid_pll_Node</td><td>is a 4D array containing the values of the nodal longitudinal structure functions as function of (lx,ly,lz) for a range of orders specified by the user. </td></tr>
    <tr><td class="paramname">counter_Grid_Node</td><td>is a 4D array containing the numbers for dividing the values of SF_Grid_pll_Node and SF_Grid_perp_Node_p so as to get the average. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a18eefe74fb861deaa5ec1731026867d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VECTOR_TEST_CASE_2D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test function to validate the calculation of structure functions of 2D velocity field data. </p>
<p>This function validates the calculation of the structure functions computed using 2D velocity field data. The velocity field is generated as \( \mathbf{u} = x \hat{x} + z \hat{z} \). For such field, the velocity structure functions of order \( q \) is given as \( S_q^u(l_x, l_z) = (\sqrt{l_x^2 + l_z^2})^q \). In this function, the theoretical values obtained from the aforementioned equation are compared with the computed values. If the difference between the two values is less than \(1 \times 10^{-10} \), the test is passed. </p>

</div>
</div>
<a class="anchor" id="ab480edbbae700c7a118450b0f91c44e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VECTOR_TEST_CASE_3D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test function to validate the calculation of structure functions of 3D velocity field data. </p>
<p>This function validates the calculation of the structure functions computed using 3D velocity field data. The velocity field is generated as \( \mathbf{u} = x \hat{x} + y \hat{y} + z \hat{z} \). For such field, the velocity structure functions of order \( q \) is given as \( S_q^u(l_x, l_y, l_z) = (\sqrt{l_x^2 + l_y^2 + l_z^2})^q \). In this function, the theoretical values obtained from the aforementioned equation are compared with the computed values. If the difference between the two values is less than \(1 \times 10^{-10} \), the test is passed. </p>

</div>
</div>
<a class="anchor" id="a16aede7be50f9f4215d24de0dad9179b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_2D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 2 &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write the structure functions as function of l as a 2D hdf5 file. </p>
<p>This function reads writes the structure functions as a 2D array of dimensions (N x p). Here, N = \(\sqrt{Nx^2 + Ny^2 + Nz^2}\) is the number of equidistant points from 0 to L, where L is the length of the diagonal of the domain in which the structure functions are calculated. p is the order of the structure functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the 2D array to store the structure functions. </td></tr>
    <tr><td class="paramname">file</td><td>is the name of the hdf5 file and the dataset in which the structure functions are stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e486782767b522541885ab5c5a7e32e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_3D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 3 &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write the structure functions as function of lx,lz as a 2D hdf5 file. </p>
<p>This function reads the structure functions as a 4D array of dimensions (lx x lz x np), where np is the order of the structure function. The structure functions of different orders are then stored as separate 2D hdf5 files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the 3D array representing the structure functions. </td></tr>
    <tr><td class="paramname">file</td><td>is the name of the hdf5 file and the dataset in which the structure functions are stored. </td></tr>
    <tr><td class="paramname">q</td><td>is the order of the structure function to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a952e4e10ef79a9b18af65437730f1080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_4D </td>
          <td>(</td>
          <td class="paramtype">Array&lt; double, 4 &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to write the structure functions as function of lx,ly,lz as a 3D hdf5 file. </p>
<p>This function reads the structure functions as a 4D array of dimensions (lx x ly x lz x np), where np is the order of the structure function. The structure functions of different orders are then stored as separate 3D hdf5 files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the 4D array representing the structure functions. </td></tr>
    <tr><td class="paramname">file</td><td>is the name of the hdf5 file and the dataset in which the structure functions are stored. </td></tr>
    <tr><td class="paramname">q</td><td>is the order of the structure function to be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a76cdfe984b21aaa9c0b85f21a1cf006a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;double,4&gt; counter_Grid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>4D array storing the counter array for averaging SF_Grid_pll and SF_Grid_perp </p>

</div>
</div>
<a class="anchor" id="adc892d1cf95116c2c9967977c8034d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Array&lt;double,3&gt; counter_Grid2D</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>3D array storing the counter array for averaging SF_Grid_pll and SF_Grid_perp </p>

</div>
</div>
<a class="anchor" id="a20e04df29613e9ca17e5d1740907a43e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool grid_switch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable decides whether the structure functions as function of (lx, ly, lz), or of (lx, lz) in case of 2D, needs to be calculated in addition to the structure functions as function of (l). </p>
<p>If the value is TRUE, then the structure functions as function of (lx, ly, lz) / (lx, lz) will be computed in addtion to the structure functions as function of (l). </p>

</div>
</div>
<a class="anchor" id="a6f513fa8d2e2fe662c220f6dd41a1e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool longitudinal</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable decides whether to calculate both transverse and longitudinal structure functions or only the longitudinal structure functions using a less computationally expensive technique. </p>
<p>If the value is false, the code calculates both transverse and longitudinal structure functions. Else, it calculates only the longitudinal structure functions using less number of iterations. </p>

</div>
</div>
<a class="anchor" id="ae07458ffa5504518f0e6eddebfcaed7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int q1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The first order of the range of orders of the structure functions to be computed. </p>
<p>Entered by the user. </p>

</div>
</div>
<a class="anchor" id="a21845db0db765ccc24cfa65647998ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int q2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The last order of the range of orders of the structure functions to be computed. </p>
<p>Entered by the user. </p>

</div>
</div>
<a class="anchor" id="a920fbb672c00642a691eee2415e31c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool scalar_switch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable decides whether the scalar or velocity structure functions are to be evaluated. </p>
<p>If the value is TRUE, then scalar structure functions will be evaluated, else the vector (velocity) structure functions will be evaluated. </p>

</div>
</div>
<a class="anchor" id="a70c213bcc57b57816ceae212036b6681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool test_switch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable decides whether the test cases are required to run. </p>
<p>If the value is "true", then the input fields will be generated internally and test cases will be run. </p>

</div>
</div>
<a class="anchor" id="a6229099a636aa31393cfa130c26452f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool two_dimension_switch</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This variable decides whether the structure functions are to be calculated using 2D or 3D velocity field data. </p>
<p>If true, then the code will read 2D velocity fields and calculate the corresponding structure functions. Otherwise, it will read 3D velocity fields. Entered by the user </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jan 25 2020 17:58:41 for Kolmogorov41 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
